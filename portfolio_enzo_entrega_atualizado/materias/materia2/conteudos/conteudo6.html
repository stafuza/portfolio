<!DOCTYPE html>
<html lang="pt-BR">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Conteúdo - Portfólio Enzo Stafuza</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <link
    href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&family=Roboto:wght@300;400;500&display=swap"
    rel="stylesheet">
  <link rel="stylesheet" href="../../../css/styles.css">
  <link rel="stylesheet" href="../../../css/conteudo.css">
  <link rel="stylesheet" href="../../../css/conteudo-responsive.css">
</head>

<body>
  <!-- Header -->
  <header>
    <div class="container header-container">
      <div class="logo">
        <a href="../../../index.html">Enzo Stafuza</a>
      </div>
      <nav>
        <ul class="nav-menu">
          <li><a href="../../../index.html">Início</a></li>
          <li><a href="../../../index.html#about">Sobre</a></li>
          <li><a href="../../../index.html#subjects">Matérias</a></li>
          <li><a href="../../../index.html#contact">Contato</a></li>
        </ul>
        <button class="mobile-menu-btn">
          <i class="fas fa-bars"></i>
        </button>
      </nav>
    </div>
  </header>

  <!-- Main Content -->
  <main>
    <section class="py-20 bg-[var(--background)]">
      <div class="container">
        <!-- Breadcrumb -->
        <div class="breadcrumb">
          <a href="../../../index.html">Início</a>
          <span class="separator">/</span>
          <a href="../../../index.html#subjects">Matérias</a>
          <span class="separator">/</span>
          <a href="../../materia2.html">Estrutura de Dados</a>
          <span class="separator">/</span>
          <span>Lista Encadeada</span>
        </div>

        <!-- Content Header -->
        <div class="content-header">
          <h1 class="text-3xl md:text-4xl font-bold mb-2">Lista Encadeada</h1>
          <div class="content-meta">
            <span>Matéria: Estrutura de Dados</span>
            <span class="dot">•</span>
            <span>Data: <span class="editable-content">15/05/2025</span></span>
          </div>
        </div>

        <!-- Content Body -->
        <div class="content-body card">
          <div class="editable-content">
            <div class="content-section">
              <h2>Listas Encadeadas</h2>
              <p> Na disciplina de Estrutura de Dados, estudamos as <strong>listas encadeadas</strong>, uma estrutura de
                dados dinâmica fundamental que organiza elementos de forma sequencial através de ponteiros, permitindo
                operações eficientes de inserção e remoção. </p>
            </div>
            <div class="content-section">
              <h3>O que são Listas Encadeadas?</h3>
              <p> Uma lista encadeada é uma coleção de nós onde cada elemento contém um valor e um ponteiro para o
                próximo nó da sequência. Diferente dos vetores, as listas encadeadas não exigem alocação contígua de
                memória. </p>
              <ul>
                <li>Cada elemento é chamado de <strong>nó</strong> (node)</li>
                <li>O primeiro nó é chamado de <strong>cabeça</strong> (head)</li>
                <li>O último nó aponta para <strong>NULL</strong></li>
                <li>Não possui tamanho fixo - cresce conforme a necessidade</li>
              </ul>
            </div>
            <div class="content-section">
              <h3>Comparação: Vetores vs Listas Encadeadas</h3>
              <table>
                <tr>
                  <th>Vetores (Arrays)</th>
                  <th>Listas Encadeadas</th>
                </tr>
                <tr>
                  <td>Tamanho fixo</td>
                  <td>Tamanho dinâmico</td>
                </tr>
                <tr>
                  <td>Alocação contígua de memória</td>
                  <td>Alocação dispersa na memória</td>
                </tr>
                <tr>
                  <td>Acesso rápido por índice (O(1))</td>
                  <td>Acesso sequencial (O(n))</td>
                </tr>
                <tr>
                  <td>Inserções/remoções custosas no meio</td>
                  <td>Inserções/remoções eficientes</td>
                </tr>
              </table>
            </div>
            <div class="content-section">
              <h3>Estrutura de um Nó</h3>
              <p> Em C, cada nó é representado por uma struct que contém: </p>
              <pre><code>struct No { int valor; // Dado armazenado struct No *prox; // Ponteiro para o próximo nó };</code></pre>
              <p> Visualização de uma lista com 3 nós: </p>
              <pre>[10 | *] → [20 | *] → [30 | NULL]</pre>
            </div>
            <div class="content-section">
              <h3>Vantagens e Desvantagens</h3>
              <div class="pros-cons">
                <div class="pros">
                  <h4>Vantagens:</h4>
                  <ul>
                    <li>Tamanho flexível (cresce/shrink conforme necessidade)</li>
                    <li>Inserções e remoções eficientes (O(1) no início)</li>
                    <li>Não desperdiça memória com alocação prévia</li>
                    <li>Ótima para implementação de pilhas e filas</li>
                  </ul>
                </div>
                <div class="cons">
                  <h4>Desvantagens:</h4>
                  <ul>
                    <li>Acesso sequencial (precisa percorrer para encontrar elementos)</li>
                    <li>Maior consumo de memória (armazena ponteiros além dos dados)</li>
                    <li>Não permite acesso aleatório eficiente</li>
                    <li>Mais complexa de implementar que arrays</li>
                  </ul>
                </div>
              </div>
            </div>
            <div class="content-section">
              <h3>Operações Principais</h3>
              <p> As operações básicas em listas encadeadas incluem: </p>
              <ul>
                <li><strong>Inserção no início</strong> - Adiciona um novo nó no começo da lista</li>
                <li><strong>Inserção no fim</strong> - Adiciona um novo nó no final da lista</li>
                <li><strong>Remoção</strong> - Remove um nó com valor específico</li>
                <li><strong>Busca</strong> - Procura um valor na lista</li>
                <li><strong>Percorrer</strong> - Visita todos os nós da lista</li>
              </ul>
            </div>
            <div class="content-section">
              <h3>Inserção no Início</h3>
              <p> Adiciona um novo elemento no começo da lista, tornando-o o novo head: </p>
              <pre><code>struct No* inserirInicio(struct No *head, int novoValor) { struct No *novoNo = (struct No*)malloc(sizeof(struct No)); novoNo->valor = novoValor; novoNo->prox = head; // Novo nó aponta para o antigo head return novoNo; // Retorna o novo nó como novo head }</code></pre>
              <p> Complexidade: O(1) - tempo constante </p>
            </div>
            <div class="content-section">
              <h3>Inserção no Fim</h3>
              <p> Adiciona um novo elemento no final da lista, exigindo percorrê-la até o último nó: </p>
              <pre><code>struct No* inserirFim(struct No *head, int novoValor) { struct No *novoNo = (struct No*)malloc(sizeof(struct No)); novoNo->valor = novoValor; novoNo->prox = NULL;
if (head == NULL) return novoNo;

struct No *atual = head;
while (atual->prox != NULL) {
    atual = atual->prox;
}
atual->prox = novoNo;
return head;
}</code></pre>

              <p> Complexidade: O(n) - precisa percorrer toda a lista </p>
            </div>
            <div class="content-section">
              <h3>Remoção de um Elemento</h3>
              <p> Remove um nó específico da lista, ajustando os ponteiros vizinhos: </p>
              <pre><code>struct No* removerElemento(struct No *head, int valor) { if (head == NULL) return NULL;
// Caso especial: remoção do primeiro nó
if (head->valor == valor) {
    struct No *temp = head->prox;
    free(head);
    return temp;
}

struct No *anterior = head;
struct No *atual = head->prox;

while (atual != NULL && atual->valor != valor) {
    anterior = atual;
    atual = atual->prox;
}

if (atual != NULL) {
    anterior->prox = atual->prox;
    free(atual);
}

return head;
}</code></pre>

            </div>
            <div class="content-section">
              <h3>Percorrer a Lista</h3>
              <p> Visita cada nó da lista sequencialmente, útil para imprimir ou processar elementos: </p>
              <pre><code>void imprimirLista(struct No *head) { struct No *atual = head; while (atual != NULL) { printf("%d -> ", atual->valor); atual = atual->prox; } printf("NULL\n"); }</code></pre>
            </div>
            <div class="content-section">
              <h3>Busca de Elemento</h3>
              <p> Procura por um valor específico na lista, retornando seu endereço se encontrado: </p>
              <pre><code>struct No* buscarElemento(struct No *head, int valor) { struct No *atual = head; while (atual != NULL) { if (atual->valor == valor) { return atual; } atual = atual->prox; } return NULL; }</code></pre>
            </div>
            <div class="content-section">
              <h3>Aplicações das Listas Encadeadas</h3>
              <p> As listas encadeadas são fundamentais para implementar: </p>
              <ul>
                <li><strong>Pilhas (Stacks)</strong> - LIFO (Last In First Out)</li>
                <li><strong>Filas (Queues)</strong> - FIFO (First In First Out)</li>
                <li><strong>Listas duplamente encadeadas</strong> - Navegação em ambas direções</li>
                <li><strong>Grafos</strong> - Representação de adjacências</li>
                <li><strong>Sistemas de arquivos</strong> - Alocação não contígua</li>
              </ul>
            </div>
            <div class="content-section">
              <h3>Conclusão</h3>
              <p> As listas encadeadas são uma estrutura de dados versátil e essencial na computação. Seu entendimento é
                crucial para avançar em estruturas mais complexas como árvores e grafos. Embora apresentem algumas
                limitações em relação a vetores, sua flexibilidade e eficiência em operações de inserção/remoção as
                tornam indispensáveis em muitos cenários de programação. </p>
              <p> O domínio das listas encadeadas prepara o terreno para estruturas derivadas como listas duplamente
                encadeadas, listas circulares e implementações avançadas de pilhas e filas. </p>
            </div>
          </div>
        </div>

        <!-- Actions -->
        <div class="actions">
          <a href="../../materia2.html" class="back-btn">
            <i class="fas fa-arrow-left"></i> Voltar para a Matéria
          </a>
          <a href="https://github.com/stafuza/Estrutura-de-Dados/tree/main/Aula%201205%20Lista%20Encadeada/Exemplos" class="github-btn"
            target="_blank">
            <i class="fab fa-github"></i> Ver no GitHub
          </a>
        </div>
      </div>
    </section>
  </main>

  <!-- Footer -->
  <footer>
    <div class="container">
      <div class="footer-content">
        <p>&copy; <span id="current-year">2025</span> Enzo Stafuza dos Santos</p>
        <p>Análise e Desenvolvimento de Sistemas - Fatec Jales</p>
        <div class="footer-social">
          <a href="https://github.com/stafuza" target="_blank" rel="noopener noreferrer">
            <i class="fab fa-github"></i>
          </a>
          <a href="https://www.linkedin.com/in/enzo-stafuza-6370a6263" target="_blank" rel="noopener noreferrer">
            <i class="fab fa-linkedin"></i>
          </a>
        </div>
      </div>
    </div>
  </footer>

  <script>
    // Atualizar o ano atual no footer
    document.getElementById('current-year').textContent = new Date().getFullYear();

    // Menu mobile toggle
    const mobileMenuBtn = document.querySelector('.mobile-menu-btn');
    const navMenu = document.querySelector('.nav-menu');

    if (mobileMenuBtn) {
      mobileMenuBtn.addEventListener('click', () => {
        navMenu.style.display = navMenu.style.display === 'flex' ? 'none' : 'flex';
      });
    }
  </script>
</body>

</html>